// Code generated by Prisma Client Go. DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"

	"github.com/prisma/prisma-client-go/engine"
	"github.com/prisma/prisma-client-go/generator/builder"
	"github.com/prisma/prisma-client-go/generator/runtime"
)

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type DateTime = runtime.DateTime

type Direction = runtime.Direction

const (
	ASC  Direction = runtime.ASC
	DESC Direction = runtime.DESC
)

const RFC3339Milli = runtime.RFC3339Milli

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "email"},
	{Name: "name"},
	{Name: "age"},
}

type iUserWith interface {
	getQuery() builder.Query
	with()
	userModel()
	userRelation()
}

type iUserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type iUserParams interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userParams struct {
	data  builder.Field
	query builder.Query
}

func (p userParams) field() builder.Field {
	return p.data
}

func (p userParams) getQuery() builder.Query {
	return p.query
}

func (p userParams) userModel() {}

type iUserOrderByParams interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParams struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParams) field() builder.Field {
	return p.data
}

func (p userOrderByParams) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParams) userModel() {}

type iUserCursorParams interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParams struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParams) field() builder.Field {
	return p.data
}

func (p userCursorParams) isCursor() {}

func (p userCursorParams) getQuery() builder.Query {
	return p.query
}

func (p userCursorParams) userModel() {}

type iUserParamsUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamsUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamsUnique) userModel() {}

func (userParamsUnique) unique() {}

func (p userParamsUnique) field() builder.Field {
	return p.data
}

func (p userParamsUnique) getQuery() builder.Query {
	return p.query
}

type iUserSetParams interface {
	field() builder.Field
	settable()
}

type userSetParams struct {
	data builder.Field
}

func (userSetParams) settable() {}

func (p userSetParams) field() builder.Field {
	return p.data
}

type userIDSetParams struct {
	data builder.Field
}

func (userIDSetParams) settable() {}

func (p userIDSetParams) field() builder.Field {
	return p.data
}

type userCreatedAtSetParams struct {
	data builder.Field
}

func (userCreatedAtSetParams) settable() {}

func (p userCreatedAtSetParams) field() builder.Field {
	return p.data
}

type userEmailSetParams struct {
	data builder.Field
}

func (userEmailSetParams) settable() {}

func (p userEmailSetParams) field() builder.Field {
	return p.data
}

type userNameSetParams struct {
	data builder.Field
}

func (userNameSetParams) settable() {}

func (p userNameSetParams) field() builder.Field {
	return p.data
}

type userAgeSetParams struct {
	data builder.Field
}

func (userAgeSetParams) settable() {}

func (p userAgeSetParams) field() builder.Field {
	return p.data
}

type userPostsSetParams struct {
	data builder.Field
}

func (userPostsSetParams) settable() {}

func (p userPostsSetParams) field() builder.Field {
	return p.data
}

type postActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var postOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "published"},
	{Name: "title"},
	{Name: "content"},
	{Name: "authorID"},
}

type iPostWith interface {
	getQuery() builder.Query
	with()
	postModel()
	postRelation()
}

type iPostRelationWith interface {
	getQuery() builder.Query
	with()
	postRelation()
}

type iPostParams interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postParams struct {
	data  builder.Field
	query builder.Query
}

func (p postParams) field() builder.Field {
	return p.data
}

func (p postParams) getQuery() builder.Query {
	return p.query
}

func (p postParams) postModel() {}

type iPostOrderByParams interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
}

type postOrderByParams struct {
	data  builder.Field
	query builder.Query
}

func (p postOrderByParams) field() builder.Field {
	return p.data
}

func (p postOrderByParams) getQuery() builder.Query {
	return p.query
}

func (p postOrderByParams) postModel() {}

type iPostCursorParams interface {
	field() builder.Field
	getQuery() builder.Query
	postModel()
	isCursor()
}

type postCursorParams struct {
	data  builder.Field
	query builder.Query
}

func (p postCursorParams) field() builder.Field {
	return p.data
}

func (p postCursorParams) isCursor() {}

func (p postCursorParams) getQuery() builder.Query {
	return p.query
}

func (p postCursorParams) postModel() {}

type iPostParamsUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	postModel()
}

type postParamsUnique struct {
	data  builder.Field
	query builder.Query
}

func (p postParamsUnique) postModel() {}

func (postParamsUnique) unique() {}

func (p postParamsUnique) field() builder.Field {
	return p.data
}

func (p postParamsUnique) getQuery() builder.Query {
	return p.query
}

type iPostSetParams interface {
	field() builder.Field
	settable()
}

type postSetParams struct {
	data builder.Field
}

func (postSetParams) settable() {}

func (p postSetParams) field() builder.Field {
	return p.data
}

type postIDSetParams struct {
	data builder.Field
}

func (postIDSetParams) settable() {}

func (p postIDSetParams) field() builder.Field {
	return p.data
}

type postCreatedAtSetParams struct {
	data builder.Field
}

func (postCreatedAtSetParams) settable() {}

func (p postCreatedAtSetParams) field() builder.Field {
	return p.data
}

type postUpdatedAtSetParams struct {
	data builder.Field
}

func (postUpdatedAtSetParams) settable() {}

func (p postUpdatedAtSetParams) field() builder.Field {
	return p.data
}

type postPublishedSetParams struct {
	data builder.Field
}

func (postPublishedSetParams) settable() {}

func (p postPublishedSetParams) field() builder.Field {
	return p.data
}

type postTitleSetParams struct {
	data builder.Field
}

func (postTitleSetParams) settable() {}

func (p postTitleSetParams) field() builder.Field {
	return p.data
}

type postContentSetParams struct {
	data builder.Field
}

func (postContentSetParams) settable() {}

func (p postContentSetParams) field() builder.Field {
	return p.data
}

type postAuthorSetParams struct {
	data builder.Field
}

func (postAuthorSetParams) settable() {}

func (p postAuthorSetParams) field() builder.Field {
	return p.data
}

type postAuthorIDSetParams struct {
	data builder.Field
}

func (postAuthorIDSetParams) settable() {}

func (p postAuthorIDSetParams) field() builder.Field {
	return p.data
}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_email userEmailSetParams,
	optional ...userSetParams,
) userCreateOne {
	var v userCreateOne
	v.query.Client = r.client
	var fields []builder.Field

	fields = append(fields, _email.data)

	for _, q := range optional {
		fields = append(fields, q.data)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userCreateOne struct {
	query builder.Query
}

func (r userCreateOne) Exec(ctx context.Context) (UserModel, error) {
	r.query.Operation = "mutation"
	r.query.Method = "createOne"
	r.query.Model = "User"
	r.query.Outputs = userOutput
	var v createOneUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return UserModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.CreateOneUser, err
}

// Creates a single user.
func (r postActions) CreateOne(
	_published postPublishedSetParams, _title postTitleSetParams, _author postAuthorSetParams,
	optional ...postSetParams,
) postCreateOne {
	var v postCreateOne
	v.query.Client = r.client
	var fields []builder.Field

	fields = append(fields, _published.data)
	fields = append(fields, _title.data)

	fields = append(fields, _author.data)

	for _, q := range optional {
		fields = append(fields, q.data)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postCreateOne struct {
	query builder.Query
}

func (r postCreateOne) Exec(ctx context.Context) (PostModel, error) {
	r.query.Operation = "mutation"
	r.query.Method = "createOne"
	r.query.Model = "Post"
	r.query.Outputs = postOutput
	var v createOnePostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return PostModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.CreateOnePost, err
}

// --- template find.gotpl ---

type userToPostFindOne struct {
	query builder.Query
}

func (r userToPostFindOne) getQuery() builder.Query {
	return r.query
}

func (r userToPostFindOne) with()         {}
func (r userToPostFindOne) userModel()    {}
func (r userToPostFindOne) userRelation() {}

func (r userToPostFindOne) With(params ...iPostRelationWith) userToPostFindOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostFindOne) Exec(ctx context.Context) (
	UserModel,
	error,
) {
	var v findOneUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return UserModel{}, fmt.Errorf(first.Message)
	}

	if v.Data.FindOneUser == nil {
		return UserModel{}, ErrNotFound
	}

	return *v.Data.FindOneUser, err
}

func (r userToPostFindOne) Update(params ...iUserSetParams) userToPostUpdateOne {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"
	r.query.Outputs = userOutput

	var v userToPostUpdateOne
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPostUpdateOne struct {
	query builder.Query
}

func (r userToPostUpdateOne) Exec(ctx context.Context) (UserModel, error) {
	var v updateOneUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return UserModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateOneUser, err
}

func (r userToPostFindOne) Delete() userToPostDeleteOne {
	var v userToPostDeleteOne
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput
	return v
}

type userToPostDeleteOne struct {
	query builder.Query
}

func (r userToPostDeleteOne) Exec(ctx context.Context) (UserModel, error) {
	var v deleteOneUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return UserModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteOneUser, err
}

type userToPostFindMany struct {
	query builder.Query
}

func (r userToPostFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToPostFindMany) with()         {}
func (r userToPostFindMany) userModel()    {}
func (r userToPostFindMany) userRelation() {}

func (r userToPostFindMany) With(params ...iPostRelationWith) userToPostFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToPostFindMany) OrderBy(param iUserOrderByParams) userToPostFindMany {
	direction, _ := param.field().Value.(runtime.Direction)
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "orderBy",
		Value: runtime.Direction(param.field().Name + "_" + string(direction)),
	})
	return r
}

func (r userToPostFindMany) Skip(count int) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToPostFindMany) First(count int) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "first",
		Value: count,
	})
	return r
}

func (r userToPostFindMany) Last(count int) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "last",
		Value: count,
	})
	return r
}

func (r userToPostFindMany) After(cursor iUserCursorParams) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "after",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPostFindMany) Before(cursor iUserCursorParams) userToPostFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "before",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToPostFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v findManyUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return []UserModel{}, fmt.Errorf(first.Message)
	}

	return v.Data.FindManyUser, err
}

func (r userToPostFindMany) Update(params ...iUserSetParams) userToPostUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"
	r.query.Outputs = countOutput

	var v userToPostUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToPostUpdateMany struct {
	query builder.Query
}

func (r userToPostUpdateMany) Exec(ctx context.Context) (int, error) {
	var v updateManyUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateManyUser.Count, err
}

func (r userToPostFindMany) Delete() userToPostDeleteMany {
	var v userToPostDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"
	v.query.Outputs = countOutput
	return v
}

type userToPostDeleteMany struct {
	query builder.Query
}

func (r userToPostDeleteMany) Exec(ctx context.Context) (int, error) {
	var v deleteManyUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteManyUser.Count, err
}

type userFindOne struct {
	query builder.Query
}

func (r userFindOne) getQuery() builder.Query {
	return r.query
}

func (r userFindOne) with()         {}
func (r userFindOne) userModel()    {}
func (r userFindOne) userRelation() {}

func (r userActions) FindOne(
	params iUserParamsUnique,
) userFindOne {
	var v userFindOne
	v.query.Client = r.client

	v.query.Operation = "query"
	v.query.Method = "findOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: []builder.Field{params.field()},
	})

	return v
}

func (r userFindOne) With(params ...iUserRelationWith) userFindOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindOne) Exec(ctx context.Context) (
	UserModel,
	error,
) {
	var v findOneUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return UserModel{}, fmt.Errorf(first.Message)
	}

	if v.Data.FindOneUser == nil {
		return UserModel{}, ErrNotFound
	}

	return *v.Data.FindOneUser, err
}

func (r userFindOne) Update(params ...iUserSetParams) userUpdateOne {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"
	r.query.Outputs = userOutput

	var v userUpdateOne
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateOne struct {
	query builder.Query
}

func (r userUpdateOne) Exec(ctx context.Context) (UserModel, error) {
	var v updateOneUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return UserModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateOneUser, err
}

func (r userFindOne) Delete() userDeleteOne {
	var v userDeleteOne
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput
	return v
}

type userDeleteOne struct {
	query builder.Query
}

func (r userDeleteOne) Exec(ctx context.Context) (UserModel, error) {
	var v deleteOneUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return UserModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteOneUser, err
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...iUserParams,
) userFindMany {
	var v userFindMany
	v.query.Client = r.client

	v.query.Operation = "query"
	v.query.Method = "findMany"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...iUserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) OrderBy(param iUserOrderByParams) userFindMany {
	direction, _ := param.field().Value.(runtime.Direction)
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "orderBy",
		Value: runtime.Direction(param.field().Name + "_" + string(direction)),
	})
	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) First(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "first",
		Value: count,
	})
	return r
}

func (r userFindMany) Last(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "last",
		Value: count,
	})
	return r
}

func (r userFindMany) After(cursor iUserCursorParams) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "after",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Before(cursor iUserCursorParams) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "before",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v findManyUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return []UserModel{}, fmt.Errorf(first.Message)
	}

	return v.Data.FindManyUser, err
}

func (r userFindMany) Update(params ...iUserSetParams) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"
	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) Exec(ctx context.Context) (int, error) {
	var v updateManyUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateManyUser.Count, err
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"
	v.query.Outputs = countOutput
	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) Exec(ctx context.Context) (int, error) {
	var v deleteManyUserResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteManyUser.Count, err
}

type postToUserFindOne struct {
	query builder.Query
}

func (r postToUserFindOne) getQuery() builder.Query {
	return r.query
}

func (r postToUserFindOne) with()         {}
func (r postToUserFindOne) postModel()    {}
func (r postToUserFindOne) postRelation() {}

func (r postToUserFindOne) With(params ...iUserRelationWith) postToUserFindOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToUserFindOne) Exec(ctx context.Context) (
	PostModel,
	error,
) {
	var v findOnePostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return PostModel{}, fmt.Errorf(first.Message)
	}

	if v.Data.FindOnePost == nil {
		return PostModel{}, ErrNotFound
	}

	return *v.Data.FindOnePost, err
}

func (r postToUserFindOne) Update(params ...iPostSetParams) postToUserUpdateOne {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"
	r.query.Outputs = postOutput

	var v postToUserUpdateOne
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToUserUpdateOne struct {
	query builder.Query
}

func (r postToUserUpdateOne) Exec(ctx context.Context) (PostModel, error) {
	var v updateOnePostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return PostModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateOnePost, err
}

func (r postToUserFindOne) Delete() postToUserDeleteOne {
	var v postToUserDeleteOne
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput
	return v
}

type postToUserDeleteOne struct {
	query builder.Query
}

func (r postToUserDeleteOne) Exec(ctx context.Context) (PostModel, error) {
	var v deleteOnePostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return PostModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteOnePost, err
}

type postToUserFindMany struct {
	query builder.Query
}

func (r postToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r postToUserFindMany) with()         {}
func (r postToUserFindMany) postModel()    {}
func (r postToUserFindMany) postRelation() {}

func (r postToUserFindMany) With(params ...iUserRelationWith) postToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postToUserFindMany) OrderBy(param iPostOrderByParams) postToUserFindMany {
	direction, _ := param.field().Value.(runtime.Direction)
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "orderBy",
		Value: runtime.Direction(param.field().Name + "_" + string(direction)),
	})
	return r
}

func (r postToUserFindMany) Skip(count int) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postToUserFindMany) First(count int) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "first",
		Value: count,
	})
	return r
}

func (r postToUserFindMany) Last(count int) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "last",
		Value: count,
	})
	return r
}

func (r postToUserFindMany) After(cursor iPostCursorParams) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "after",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToUserFindMany) Before(cursor iPostCursorParams) postToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "before",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postToUserFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v findManyPostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return []PostModel{}, fmt.Errorf(first.Message)
	}

	return v.Data.FindManyPost, err
}

func (r postToUserFindMany) Update(params ...iPostSetParams) postToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"
	r.query.Outputs = countOutput

	var v postToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postToUserUpdateMany struct {
	query builder.Query
}

func (r postToUserUpdateMany) Exec(ctx context.Context) (int, error) {
	var v updateManyPostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateManyPost.Count, err
}

func (r postToUserFindMany) Delete() postToUserDeleteMany {
	var v postToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"
	v.query.Outputs = countOutput
	return v
}

type postToUserDeleteMany struct {
	query builder.Query
}

func (r postToUserDeleteMany) Exec(ctx context.Context) (int, error) {
	var v deleteManyPostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteManyPost.Count, err
}

type postFindOne struct {
	query builder.Query
}

func (r postFindOne) getQuery() builder.Query {
	return r.query
}

func (r postFindOne) with()         {}
func (r postFindOne) postModel()    {}
func (r postFindOne) postRelation() {}

func (r postActions) FindOne(
	params iPostParamsUnique,
) postFindOne {
	var v postFindOne
	v.query.Client = r.client

	v.query.Operation = "query"
	v.query.Method = "findOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: []builder.Field{params.field()},
	})

	return v
}

func (r postFindOne) With(params ...iPostRelationWith) postFindOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindOne) Exec(ctx context.Context) (
	PostModel,
	error,
) {
	var v findOnePostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return PostModel{}, fmt.Errorf(first.Message)
	}

	if v.Data.FindOnePost == nil {
		return PostModel{}, ErrNotFound
	}

	return *v.Data.FindOnePost, err
}

func (r postFindOne) Update(params ...iPostSetParams) postUpdateOne {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Post"
	r.query.Outputs = postOutput

	var v postUpdateOne
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateOne struct {
	query builder.Query
}

func (r postUpdateOne) Exec(ctx context.Context) (PostModel, error) {
	var v updateOnePostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return PostModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateOnePost, err
}

func (r postFindOne) Delete() postDeleteOne {
	var v postDeleteOne
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Post"
	v.query.Outputs = postOutput
	return v
}

type postDeleteOne struct {
	query builder.Query
}

func (r postDeleteOne) Exec(ctx context.Context) (PostModel, error) {
	var v deleteOnePostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return PostModel{}, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteOnePost, err
}

type postFindMany struct {
	query builder.Query
}

func (r postFindMany) getQuery() builder.Query {
	return r.query
}

func (r postFindMany) with()         {}
func (r postFindMany) postModel()    {}
func (r postFindMany) postRelation() {}

func (r postActions) FindMany(
	params ...iPostParams,
) postFindMany {
	var v postFindMany
	v.query.Client = r.client

	v.query.Operation = "query"
	v.query.Method = "findMany"
	v.query.Model = "Post"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r postFindMany) With(params ...iPostRelationWith) postFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r postFindMany) OrderBy(param iPostOrderByParams) postFindMany {
	direction, _ := param.field().Value.(runtime.Direction)
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "orderBy",
		Value: runtime.Direction(param.field().Name + "_" + string(direction)),
	})
	return r
}

func (r postFindMany) Skip(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r postFindMany) First(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "first",
		Value: count,
	})
	return r
}

func (r postFindMany) Last(count int) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "last",
		Value: count,
	})
	return r
}

func (r postFindMany) After(cursor iPostCursorParams) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "after",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindMany) Before(cursor iPostCursorParams) postFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "before",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r postFindMany) Exec(ctx context.Context) (
	[]PostModel,
	error,
) {
	var v findManyPostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return []PostModel{}, fmt.Errorf(first.Message)
	}

	return v.Data.FindManyPost, err
}

func (r postFindMany) Update(params ...iPostSetParams) postUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Post"
	r.query.Outputs = countOutput

	var v postUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type postUpdateMany struct {
	query builder.Query
}

func (r postUpdateMany) Exec(ctx context.Context) (int, error) {
	var v updateManyPostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.UpdateManyPost.Count, err
}

func (r postFindMany) Delete() postDeleteMany {
	var v postDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Post"
	v.query.Outputs = countOutput
	return v
}

type postDeleteMany struct {
	query builder.Query
}

func (r postDeleteMany) Exec(ctx context.Context) (int, error) {
	var v deleteManyPostResponse
	err := r.query.Exec(ctx, &v)
	if v.Errors != nil {
		first := v.Errors[0]
		return -1, fmt.Errorf(first.Message)
	}
	return v.Data.DeleteManyPost.Count, err
}

// --- template structs.gotpl ---

type findOneUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		FindOneUser *UserModel `json:"findOneUser"`
	} `json:"data"`
}

type findOneUserResult struct {
	Count int `json:"count"`
}

type findManyUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		FindManyUser []UserModel `json:"findManyUser"`
	} `json:"data"`
}

type findManyUserResult struct {
	Count int `json:"count"`
}

type createOneUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		CreateOneUser UserModel `json:"createOneUser"`
	} `json:"data"`
}

type createOneUserResult struct {
	Count int `json:"count"`
}

type createManyUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		CreateManyUser createManyUserResult `json:"createManyUser"`
	} `json:"data"`
}

type createManyUserResult struct {
	Count int `json:"count"`
}

type updateOneUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		UpdateOneUser UserModel `json:"updateOneUser"`
	} `json:"data"`
}

type updateOneUserResult struct {
	Count int `json:"count"`
}

type updateManyUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		UpdateManyUser updateManyUserResult `json:"updateManyUser"`
	} `json:"data"`
}

type updateManyUserResult struct {
	Count int `json:"count"`
}

type deleteOneUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		DeleteOneUser UserModel `json:"deleteOneUser"`
	} `json:"data"`
}

type deleteOneUserResult struct {
	Count int `json:"count"`
}

type deleteManyUserResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		DeleteManyUser deleteManyUserResult `json:"deleteManyUser"`
	} `json:"data"`
}

type deleteManyUserResult struct {
	Count int `json:"count"`
}

type findOnePostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		FindOnePost *PostModel `json:"findOnePost"`
	} `json:"data"`
}

type findOnePostResult struct {
	Count int `json:"count"`
}

type findManyPostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		FindManyPost []PostModel `json:"findManyPost"`
	} `json:"data"`
}

type findManyPostResult struct {
	Count int `json:"count"`
}

type createOnePostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		CreateOnePost PostModel `json:"createOnePost"`
	} `json:"data"`
}

type createOnePostResult struct {
	Count int `json:"count"`
}

type createManyPostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		CreateManyPost createManyPostResult `json:"createManyPost"`
	} `json:"data"`
}

type createManyPostResult struct {
	Count int `json:"count"`
}

type updateOnePostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		UpdateOnePost PostModel `json:"updateOnePost"`
	} `json:"data"`
}

type updateOnePostResult struct {
	Count int `json:"count"`
}

type updateManyPostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		UpdateManyPost updateManyPostResult `json:"updateManyPost"`
	} `json:"data"`
}

type updateManyPostResult struct {
	Count int `json:"count"`
}

type deleteOnePostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		DeleteOnePost PostModel `json:"deleteOnePost"`
	} `json:"data"`
}

type deleteOnePostResult struct {
	Count int `json:"count"`
}

type deleteManyPostResponse struct {
	Errors []engine.GQLError `json:"errors"`
	Data   struct {
		DeleteManyPost deleteManyPostResult `json:"deleteManyPost"`
	} `json:"data"`
}

type deleteManyPostResult struct {
	Count int `json:"count"`
}

// --- template client.gotpl ---
const schema = `datasource db {
  provider = "sqlite"
  url      = "file:dev.db"
}

generator db {
  provider = "go run github.com/prisma/prisma-client-go"
  output = "./db/db_gen.go"
  package = "db"
}

model User {
  id        String   @default(cuid()) @id
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
  age       Int?

  posts     Post[]
}

model Post {
  id        String   @default(cuid()) @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean
  title     String
  content   String?

  author   User @relation(fields: [authorID], references: [id])
  authorID String
}`

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = false

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//   client := db.NewClient()
//   err := client.Connect()
//   if err != nil {
//     handle(err)
//   }
//
//   defer func() {
//     err := client.Disconnect()
//     if err != nil {
//       panic(fmt.Errorf("could not disconnect: %w", err))
//     }
//   }()
func NewClient() *PrismaClient {
	c := &PrismaClient{}

	c.Engine = engine.NewEngine(schema, hasBinaryTargets)
	c.User = userActions{client: c}
	c.Post = postActions{client: c}

	return c
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine spawns and manages the binary
	*engine.Engine

	// User provides access to CRUD methods.
	User userActions
	// Post provides access to CRUD methods.
	Post postActions
}

// Connects to the Prisma query engine. Required to call before accessing data.
// It is recommended to immediately defer calling Disconnect.
//
// Example:
//
//   err := client.Connect()
//   if err != nil {
//     handle(err)
//   }
//
//   defer func() {
//     err := client.Disconnect()
//     if err != nil {
//       panic(fmt.Errorf("could not disconnect: %w", err))
//     }
//   }()
func (c *PrismaClient) Connect() error {
	return c.Engine.Connect()
}

// Disconnects from the Prisma query engine.
// This is usually invoked on kill signals in long running applications (like webservers),
// or when no database access is needed anymore (like after executing a CLI command).
//
// Should be usually invoked directly after calling client.Connect(), for example as follows:
//
//   // after client.Connect()
//
//   defer func() {
//     err := client.Disconnect()
//     if err != nil {
//       panic(fmt.Errorf("could not disconnect: %w", err))
//     }
//   }()
func (c *PrismaClient) Disconnect() error {
	return c.Engine.Disconnect()
}

// --- template enums.gotpl ---

// --- template errors.gotpl ---
// ErrNotFound gets returned when a database record does not exist
var ErrNotFound = errors.New("ErrNotFound")

// --- template models.gotpl ---

// UserModel represents the `json:"User"` model and is a wrapper for accessing fields and methods
type UserModel struct {
	RawUser
	RelationsUser
}

// RawUser holds the actual data
type RawUser struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	Email     string   `json:"email"`
	Name      *string  `json:"name"`
	Age       *int     `json:"age"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
	Posts []PostModel `json:"posts"`
}

func (r UserModel) Name() (value string, ok bool) {
	if r.RawUser.Name == nil {
		return value, false
	}
	return *r.RawUser.Name, true
}

func (r UserModel) Age() (value int, ok bool) {
	if r.RawUser.Age == nil {
		return value, false
	}
	return *r.RawUser.Age, true
}

func (r UserModel) Posts() (value []PostModel) {
	if r.RelationsUser.Posts == nil {
		panic("attempted to access posts but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Posts
}

// PostModel represents the `json:"Post"` model and is a wrapper for accessing fields and methods
type PostModel struct {
	RawPost
	RelationsPost
}

// RawPost holds the actual data
type RawPost struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
	Published bool     `json:"published"`
	Title     string   `json:"title"`
	Content   *string  `json:"content"`
	AuthorID  string   `json:"authorID"`
}

// RelationsPost holds the relation data separately
type RelationsPost struct {
	Author *UserModel `json:"author"`
}

func (r PostModel) Content() (value string, ok bool) {
	if r.RawPost.Content == nil {
		return value, false
	}
	return *r.RawPost.Content, true
}

func (r PostModel) Author() (value UserModel, ok bool) {
	if r.RelationsPost.Author == nil {
		panic("attempted to access author but did not fetch it using the .With() syntax")
	}
	return *r.RelationsPost.Author, true
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {
	// ID
	//
	// @required
	ID userQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// Email
	//
	// @required
	// @unique
	Email userQueryEmailString

	// Name
	//
	// @optional
	Name userQueryNameString

	// Age
	//
	// @optional
	Age userQueryAgeInt

	Posts userQueryPostsRelations
}

func (userQuery) Not(params ...iUserParams) userParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userParams{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...iUserParams) userParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userParams{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParams {
	return userSetParams{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}
}

func (r userQueryIDString) Equals(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}
}

func (r userQueryIDString) In(values []string) userParamsUnique {
	f := builder.Field{
		Name:   "id",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return userParamsUnique{
		data: f,
	}
}

func (r userQueryIDString) Order(direction runtime.Direction) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParams {
	return userCursorParams{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) Contains(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Action: "contains",
			Name:   "id",
			Value:  value,
		},
	}
}

func (r userQueryIDString) HasPrefix(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Action: "starts_with",
			Name:   "id",
			Value:  value,
		},
	}
}

func (r userQueryIDString) HasSuffix(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Action: "ends_with",
			Name:   "id",
			Value:  value,
		},
	}
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParams {
	return userSetParams{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userParams {
	return userParams{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(values []DateTime) userParams {
	f := builder.Field{
		Name:   "createdAt",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return userParams{
		data: f,
	}
}

func (r userQueryCreatedAtDateTime) Order(direction runtime.Direction) userParams {
	return userParams{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Before(value DateTime) userParams {
	return userParams{
		data: builder.Field{
			Action: "lt",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

func (r userQueryCreatedAtDateTime) After(value DateTime) userParams {
	return userParams{
		data: builder.Field{
			Action: "gt",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userParams {
	return userParams{
		data: builder.Field{
			Action: "lte",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userParams {
	return userParams{
		data: builder.Field{
			Action: "gte",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

// base struct
type userQueryEmailString struct{}

// Set the required value of Email
func (r userQueryEmailString) Set(value string) userEmailSetParams {
	return userEmailSetParams{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}
}

func (r userQueryEmailString) Equals(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}
}

func (r userQueryEmailString) In(values []string) userParamsUnique {
	f := builder.Field{
		Name:   "email",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return userParamsUnique{
		data: f,
	}
}

func (r userQueryEmailString) Order(direction runtime.Direction) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userQueryEmailString) Cursor(cursor string) userCursorParams {
	return userCursorParams{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userQueryEmailString) Contains(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Action: "contains",
			Name:   "email",
			Value:  value,
		},
	}
}

func (r userQueryEmailString) HasPrefix(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Action: "starts_with",
			Name:   "email",
			Value:  value,
		},
	}
}

func (r userQueryEmailString) HasSuffix(value string) userParamsUnique {
	return userParamsUnique{
		data: builder.Field{
			Action: "ends_with",
			Name:   "email",
			Value:  value,
		},
	}
}

// base struct
type userQueryNameString struct{}

// Set the optional value of Name
func (r userQueryNameString) Set(value string) userSetParams {
	return userSetParams{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}
}

// Set the optional value of Name dynamically
func (r userQueryNameString) SetOptional(value *string) userSetParams {
	return userSetParams{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}
}

func (r userQueryNameString) Equals(value string) userParams {
	return userParams{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}
}

func (r userQueryNameString) In(values []string) userParams {
	f := builder.Field{
		Name:   "name",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return userParams{
		data: f,
	}
}

func (r userQueryNameString) EqualsOptional(value *string) userParams {
	return userParams{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}
}

func (r userQueryNameString) IsNull() userParams {
	var str *string = nil
	return userParams{
		data: builder.Field{
			Name:  "name",
			Value: str,
		},
	}
}

func (r userQueryNameString) Order(direction runtime.Direction) userParams {
	return userParams{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r userQueryNameString) Contains(value string) userParams {
	return userParams{
		data: builder.Field{
			Action: "contains",
			Name:   "name",
			Value:  value,
		},
	}
}

func (r userQueryNameString) HasPrefix(value string) userParams {
	return userParams{
		data: builder.Field{
			Action: "starts_with",
			Name:   "name",
			Value:  value,
		},
	}
}

func (r userQueryNameString) HasSuffix(value string) userParams {
	return userParams{
		data: builder.Field{
			Action: "ends_with",
			Name:   "name",
			Value:  value,
		},
	}
}

// base struct
type userQueryAgeInt struct{}

// Set the optional value of Age
func (r userQueryAgeInt) Set(value int) userSetParams {
	return userSetParams{
		data: builder.Field{
			Name:  "age",
			Value: value,
		},
	}
}

// Set the optional value of Age dynamically
func (r userQueryAgeInt) SetOptional(value *int) userSetParams {
	return userSetParams{
		data: builder.Field{
			Name:  "age",
			Value: value,
		},
	}
}

func (r userQueryAgeInt) Equals(value int) userParams {
	return userParams{
		data: builder.Field{
			Name:  "age",
			Value: value,
		},
	}
}

func (r userQueryAgeInt) In(values []int) userParams {
	f := builder.Field{
		Name:   "age",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return userParams{
		data: f,
	}
}

func (r userQueryAgeInt) EqualsOptional(value *int) userParams {
	return userParams{
		data: builder.Field{
			Name:  "age",
			Value: value,
		},
	}
}

func (r userQueryAgeInt) IsNull() userParams {
	var str *string = nil
	return userParams{
		data: builder.Field{
			Name:  "age",
			Value: str,
		},
	}
}

func (r userQueryAgeInt) Order(direction runtime.Direction) userParams {
	return userParams{
		data: builder.Field{
			Name:  "age",
			Value: direction,
		},
	}
}

func (r userQueryAgeInt) LT(value int) userParams {
	return userParams{
		data: builder.Field{
			Action: "lt",
			Name:   "age",
			Value:  value,
		},
	}
}

func (r userQueryAgeInt) GT(value int) userParams {
	return userParams{
		data: builder.Field{
			Action: "gt",
			Name:   "age",
			Value:  value,
		},
	}
}

func (r userQueryAgeInt) LTE(value int) userParams {
	return userParams{
		data: builder.Field{
			Action: "lte",
			Name:   "age",
			Value:  value,
		},
	}
}

func (r userQueryAgeInt) GTE(value int) userParams {
	return userParams{
		data: builder.Field{
			Action: "gte",
			Name:   "age",
			Value:  value,
		},
	}
}

// base struct
type userQueryPostsPost struct{}

type userQueryPostsRelations struct{}

// User -> Posts
//
// @relation
// @optional
func (userQueryPostsRelations) Some(
	params ...iPostParams,
) userParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userParams{
		data: builder.Field{
			Name:   "posts",
			Action: "some",
			Fields: fields,
		},
	}
}

// User -> Posts
//
// @relation
// @optional
func (userQueryPostsRelations) Every(
	params ...iPostParams,
) userParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userParams{
		data: builder.Field{
			Name:   "posts",
			Action: "every",
			Fields: fields,
		},
	}
}

func (userQueryPostsRelations) Fetch(

	params ...iPostParams,

) userToPostFindMany {
	var v userToPostFindMany

	v.query.Operation = "query"
	v.query.Method = "posts"
	v.query.Outputs = postOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryPostsRelations) Link(
	params ...iPostParams,
) userSetParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParams{
		data: builder.Field{
			Name: "posts",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: fields,
				},
			},
		},
	}
}

// Post acts as a namespaces to access query methods for the Post model
var Post = postQuery{}

// postQuery exposes query functions for the post model
type postQuery struct {
	// ID
	//
	// @required
	ID postQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt postQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt postQueryUpdatedAtDateTime

	// Published
	//
	// @required
	Published postQueryPublishedBoolean

	// Title
	//
	// @required
	Title postQueryTitleString

	// Content
	//
	// @optional
	Content postQueryContentString

	Author postQueryAuthorRelations

	// AuthorID
	//
	// @required
	AuthorID postQueryAuthorIDString
}

func (postQuery) Not(params ...iPostParams) postParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postParams{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (postQuery) Or(params ...iPostParams) postParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postParams{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type postQueryIDString struct{}

// Set the required value of ID
func (r postQueryIDString) Set(value string) postSetParams {
	return postSetParams{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}
}

func (r postQueryIDString) Equals(value string) postParamsUnique {
	return postParamsUnique{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}
}

func (r postQueryIDString) In(values []string) postParamsUnique {
	f := builder.Field{
		Name:   "id",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return postParamsUnique{
		data: f,
	}
}

func (r postQueryIDString) Order(direction runtime.Direction) postParamsUnique {
	return postParamsUnique{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r postQueryIDString) Cursor(cursor string) postCursorParams {
	return postCursorParams{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r postQueryIDString) Contains(value string) postParamsUnique {
	return postParamsUnique{
		data: builder.Field{
			Action: "contains",
			Name:   "id",
			Value:  value,
		},
	}
}

func (r postQueryIDString) HasPrefix(value string) postParamsUnique {
	return postParamsUnique{
		data: builder.Field{
			Action: "starts_with",
			Name:   "id",
			Value:  value,
		},
	}
}

func (r postQueryIDString) HasSuffix(value string) postParamsUnique {
	return postParamsUnique{
		data: builder.Field{
			Action: "ends_with",
			Name:   "id",
			Value:  value,
		},
	}
}

// base struct
type postQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r postQueryCreatedAtDateTime) Set(value DateTime) postSetParams {
	return postSetParams{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}
}

func (r postQueryCreatedAtDateTime) Equals(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}
}

func (r postQueryCreatedAtDateTime) In(values []DateTime) postParams {
	f := builder.Field{
		Name:   "createdAt",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return postParams{
		data: f,
	}
}

func (r postQueryCreatedAtDateTime) Order(direction runtime.Direction) postParams {
	return postParams{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r postQueryCreatedAtDateTime) Before(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "lt",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

func (r postQueryCreatedAtDateTime) After(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "gt",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

func (r postQueryCreatedAtDateTime) BeforeEquals(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "lte",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

func (r postQueryCreatedAtDateTime) AfterEquals(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "gte",
			Name:   "createdAt",
			Value:  value,
		},
	}
}

// base struct
type postQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r postQueryUpdatedAtDateTime) Set(value DateTime) postSetParams {
	return postSetParams{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}
}

func (r postQueryUpdatedAtDateTime) Equals(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}
}

func (r postQueryUpdatedAtDateTime) In(values []DateTime) postParams {
	f := builder.Field{
		Name:   "updatedAt",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return postParams{
		data: f,
	}
}

func (r postQueryUpdatedAtDateTime) Order(direction runtime.Direction) postParams {
	return postParams{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r postQueryUpdatedAtDateTime) Before(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "lt",
			Name:   "updatedAt",
			Value:  value,
		},
	}
}

func (r postQueryUpdatedAtDateTime) After(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "gt",
			Name:   "updatedAt",
			Value:  value,
		},
	}
}

func (r postQueryUpdatedAtDateTime) BeforeEquals(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "lte",
			Name:   "updatedAt",
			Value:  value,
		},
	}
}

func (r postQueryUpdatedAtDateTime) AfterEquals(value DateTime) postParams {
	return postParams{
		data: builder.Field{
			Action: "gte",
			Name:   "updatedAt",
			Value:  value,
		},
	}
}

// base struct
type postQueryPublishedBoolean struct{}

// Set the required value of Published
func (r postQueryPublishedBoolean) Set(value bool) postPublishedSetParams {
	return postPublishedSetParams{
		data: builder.Field{
			Name:  "published",
			Value: value,
		},
	}
}

func (r postQueryPublishedBoolean) Equals(value bool) postParams {
	return postParams{
		data: builder.Field{
			Name:  "published",
			Value: value,
		},
	}
}

func (r postQueryPublishedBoolean) In(values []bool) postParams {
	f := builder.Field{
		Name:   "published",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return postParams{
		data: f,
	}
}

func (r postQueryPublishedBoolean) Order(direction runtime.Direction) postParams {
	return postParams{
		data: builder.Field{
			Name:  "published",
			Value: direction,
		},
	}
}

// base struct
type postQueryTitleString struct{}

// Set the required value of Title
func (r postQueryTitleString) Set(value string) postTitleSetParams {
	return postTitleSetParams{
		data: builder.Field{
			Name:  "title",
			Value: value,
		},
	}
}

func (r postQueryTitleString) Equals(value string) postParams {
	return postParams{
		data: builder.Field{
			Name:  "title",
			Value: value,
		},
	}
}

func (r postQueryTitleString) In(values []string) postParams {
	f := builder.Field{
		Name:   "title",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return postParams{
		data: f,
	}
}

func (r postQueryTitleString) Order(direction runtime.Direction) postParams {
	return postParams{
		data: builder.Field{
			Name:  "title",
			Value: direction,
		},
	}
}

func (r postQueryTitleString) Contains(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "contains",
			Name:   "title",
			Value:  value,
		},
	}
}

func (r postQueryTitleString) HasPrefix(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "starts_with",
			Name:   "title",
			Value:  value,
		},
	}
}

func (r postQueryTitleString) HasSuffix(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "ends_with",
			Name:   "title",
			Value:  value,
		},
	}
}

// base struct
type postQueryContentString struct{}

// Set the optional value of Content
func (r postQueryContentString) Set(value string) postSetParams {
	return postSetParams{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}
}

// Set the optional value of Content dynamically
func (r postQueryContentString) SetOptional(value *string) postSetParams {
	return postSetParams{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}
}

func (r postQueryContentString) Equals(value string) postParams {
	return postParams{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}
}

func (r postQueryContentString) In(values []string) postParams {
	f := builder.Field{
		Name:   "content",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return postParams{
		data: f,
	}
}

func (r postQueryContentString) EqualsOptional(value *string) postParams {
	return postParams{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}
}

func (r postQueryContentString) IsNull() postParams {
	var str *string = nil
	return postParams{
		data: builder.Field{
			Name:  "content",
			Value: str,
		},
	}
}

func (r postQueryContentString) Order(direction runtime.Direction) postParams {
	return postParams{
		data: builder.Field{
			Name:  "content",
			Value: direction,
		},
	}
}

func (r postQueryContentString) Contains(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "contains",
			Name:   "content",
			Value:  value,
		},
	}
}

func (r postQueryContentString) HasPrefix(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "starts_with",
			Name:   "content",
			Value:  value,
		},
	}
}

func (r postQueryContentString) HasSuffix(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "ends_with",
			Name:   "content",
			Value:  value,
		},
	}
}

// base struct
type postQueryAuthorUser struct{}

type postQueryAuthorRelations struct{}

// Post -> Author
//
// @relation
// @required
func (postQueryAuthorRelations) Where(
	params ...iUserParams,
) postParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postParams{
		data: builder.Field{
			Name:   "author",
			Action: "",
			Fields: fields,
		},
	}
}

func (postQueryAuthorRelations) Fetch() postToUserFindOne {
	var v postToUserFindOne

	v.query.Operation = "query"
	v.query.Method = "author"
	v.query.Outputs = userOutput

	return v
}

func (r postQueryAuthorRelations) Link(
	params ...iUserParams,
) postAuthorSetParams {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return postAuthorSetParams{
		data: builder.Field{
			Name: "author",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: fields,
				},
			},
		},
	}
}

// base struct
type postQueryAuthorIDString struct{}

// Set the required value of AuthorID
func (r postQueryAuthorIDString) Set(value string) postAuthorIDSetParams {
	return postAuthorIDSetParams{
		data: builder.Field{
			Name:  "authorID",
			Value: value,
		},
	}
}

func (r postQueryAuthorIDString) Equals(value string) postParams {
	return postParams{
		data: builder.Field{
			Name:  "authorID",
			Value: value,
		},
	}
}

func (r postQueryAuthorIDString) In(values []string) postParams {
	f := builder.Field{
		Name:   "authorID",
		Action: "in",
		List:   true,
	}
	for _, v := range values {
		f.Fields = append(f.Fields, builder.Field{
			Value: v,
		})
	}
	return postParams{
		data: f,
	}
}

func (r postQueryAuthorIDString) Order(direction runtime.Direction) postParams {
	return postParams{
		data: builder.Field{
			Name:  "authorID",
			Value: direction,
		},
	}
}

func (r postQueryAuthorIDString) Contains(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "contains",
			Name:   "authorID",
			Value:  value,
		},
	}
}

func (r postQueryAuthorIDString) HasPrefix(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "starts_with",
			Name:   "authorID",
			Value:  value,
		},
	}
}

func (r postQueryAuthorIDString) HasSuffix(value string) postParams {
	return postParams{
		data: builder.Field{
			Action: "ends_with",
			Name:   "authorID",
			Value:  value,
		},
	}
}
